# StatechartSharp 简介

> 我在接触 Godot 时，因为没找到合适的状态机教程，就做了这个插件。

## 新的节点

主要的节点就 4 个：

- Statechart ：整个 Statechart 的根节点（你可以把它当作“状态机”节点）
- State ：状态节点。
- Transition ：表示状态之间“转换”的节点。
- Reaction：表示状态“做什么”的节点（规范里称为 action ，但是太冲突了就改成 reaction）。

还有一个 TransitionPromoter 节点，是用来提升 Transition 优先级的。

节点提供了一些信号，可以让你不扩展脚本就实现状态机功能。

## 快速搭建状态机

Statechart 各处细节还是比较繁琐的，但是你完全可以把它当作基础的状态机来使用。

首先创建一个 Statechart 节点，然后添加一些 State 节点。注意我们需要一个”根状态节点“（即使你的状态机是单层的），在根节点下再放置更多的状态节点。

注意 State 节点放置的顺序是**有影响**的，包括之后要用的 Transition 、 Reaction 。这些节点（展开所有层级）在编辑器中**从上到下**的顺序叫做”文本序“（Document order），各种遍历操作都要用。

还有你需要注意，状态机初始会默认激活第一个状态，然后继续激活它子节点中第一个状态。比方说你要做一个角色控制器，你会希望初始是静止的”IDLE“状态：

```
Player
    └─Statechart
        └─Root // <- 初始激活的状态
            ├─Idle // <- 初始激活的状态
            ├─Walk
            └─Airborne
```

然后你可能就想，是不是要和其他那些状态机教程一样要开始编写 `StateIdle.cs` `StateWalk.cs` 这样的脚本，放在 `./scripts/player/states` 这样的文件夹里……

别急。首先扩展脚本也是可以的，但这个插件可以让你完全使用信号！另外我们的状态节点只关心”进入“和”离开“时需要做什么（Enter/Exit 信号），而状态转换、状态”平时做些什么“分别是由 Transition 、 Reaction 节点表示。

那么我们先加入一些 Transition 节点。Transition 是隶属于某一个状态的，我们把它添加为状态的子节点，就表示从这个状态出发的转换：

```
Statechart
    └─Root
        ├─Idle
        │   └─ToWalk // <- 从 Idle 到 Walk 的转换
        ├─Walk
        └─Airborne
```

至于转换的目标状态，你可以在 Transition 的 Targets 属性里添加。你会发现目标状态可以设置多个，这是因为我们的状态有其他模式，可以支持同一层级中有多个状态同时激活。

接下来比方说我们的角色控制器想在 Process 阶段检查输入看是不是
