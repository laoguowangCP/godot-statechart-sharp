# StatechartSharp 简介

> 我在接触 Godot 时，因为没找到合适的状态机教程，就做了这个插件。

## 新的节点

主要的节点就 4 个：

- Statechart ：整个 Statechart 的根节点（你可以把它当作“状态机”节点）
- State ：状态节点。
- Transition ：表示状态之间“转换”的节点。
- Reaction：表示状态“做什么”的节点（规范里称为 action ，但是太冲突了就改成 reaction）。

还有一个 TransitionPromoter 节点，是用来提升 Transition 优先级的。

使用这些节点可以在编辑器中搭建。节点还提供了一些信号，可以让你不扩展脚本就实现状态机功能。

## 快速搭建状态机

Statechart 各处细节还是比较繁琐的，但是你完全可以把它当作基础的状态机来使用。

首先创建一个 Statechart 节点，然后添加一些 State 节点。注意我们需要一个”根状态节点“（即使你的状态机是单层的），在根节点下再放置更多的状态节点。

注意 State 节点放置的顺序是**有影响**的，包括之后要用的 Transition 、 Reaction 。这些节点（展开所有层级）在编辑器中**从上到下**的顺序叫做”文本序“（Document order），各种遍历操作都要用。

还有你需要注意，状态机初始会默认激活第一个状态，然后继续激活它子节点中第一个状态。比方说你要做一个角色控制器，你会希望初始是静止的”IDLE“状态：

```
Player
    └─Statechart
        └─Root // <- 初始激活的状态
            ├─Idle // <- 初始激活的状态
            ├─Walk
            └─Airborne
```

然后你可能就想，是不是要和其他那些状态机教程一样要开始编写 `StateIdle.cs` `StateWalk.cs` 这样的脚本，放在 `./scripts/player/states` 这样的文件夹里……

别急。首先扩展脚本也是可以的，但这个插件可以让你完全使用信号！另外我们的状态节点只关心”进入“和”离开“时需要做什么（Enter/Exit 信号），而状态转换、状态”平时做些什么“分别是由 Transition 、 Reaction 节点表示。

那么我们先加入一些 Transition 节点。Transition 是隶属于某一个状态的，我们把它添加为状态的子节点，就表示从这个状态出发的转换：

```
Statechart
    └─Root
        ├─Idle
        │   └─ToWalk // <- 从 Idle 到 Walk 的转换
        ├─Walk
        └─Airborne
```

至于转换的目标状态，你可以在 Transition 的 Targets 属性里添加。你会发现目标状态可以设置多个，这是因为我们的状态有其他模式，可以支持同一层级中有多个状态同时激活。

设置好转换目标后，我们还需要判断转换是否要发生。比方说检测角色是否在空中，在 Process 阶段使用 `CharacterBody.IsOnFloor()` ，就需要连接 `void Guard(StatechartDuct)` 信号：意味着你需要一个函数，具有 `void` 返回值，以及一个 `StatechartDuct` 参数。比方说你的角色控制器上下文在 CharacterBody2D/3D 里，你可以在此处编写你的函数，连接到状态转移的 Guard 信号上：

```csharp
public void GroundToAir(StatechartDuct duct)
{
    duct.IsEnabled = !IsOnFloor();
}
```

StatechartDuct 是状态机用于与外界交流的对象。比方说此处 Transition 想要知道它是否需要执行转移，因此调用 Guard 信号，而我们编写的外部函数则告诉它如果不在地面就发生转移。 `bool StatechartDuct.IsEnabled` 就是 Transition 决定是否发生转移的依据。StatechartDuct 会传递节点 Process、Input 等生命周期函数的参数，供通过信号连接的函数使用，此外还会传递 IsEnabled 这个专门用于 Guard 信号的布尔值，还会传递基础信息：发射信号的状态机节点 CompositionNode（StatechartComposition 类型，是 Statechart 各个组件节点的基类），以及 Statechart 是否正在运行 IsRunning 。

最后我们还没有确定状态转移的判断、发生的时机（事件）：可以选择属性中的 TransitionEvent ，你会看到有 Process 、 Input 等节点生命周期函数对应的事件，以及两个额外事件：

- Custom 是自定义事件，选这个的话就需要在下面的 CustomEventName 里输入事件的名称。
- Auto 是自动转移（Automatic Transition），不再响应特定事件，而是只要有任何事件发生，它都会去判断是否转移。

设定完 Transition ，我们还需要回到 Statechart 节点，可以看到有 EventFlag 可以勾选。默认是都不勾选的，Statechart 也就不会响应任何生命周期函数事件，所以你可以根据需要勾选一下。另外对于自定义的事件，我们需要手动调用 `void Statechart.Step(StringName)` 方法，参数就是事件的名称。

Transition 还有一个信号 Invoke ，是用来表达转换真的发生时要做些什么。某个状态拥有的多个 Transition 会按照从上到下的顺序判别。

先暂时放一下 Transition ，我们回头看一下状态节点，它们有 Enter 和 Exit 信号，用于在状态转移发生时表达进入/离开的行为，至于某个状态中具体会做些什么，我们需要继续添加 Reaction 子节点，连接它的 Invoke 信号。同样地 Reaction 也有一样的选择发生的时机的 ReactionEvent （除了 Auto ，这个是 Transition 专用的）。
